#Linux的内存管理机制
在Linux系统下，监控内存常用的命令是free、top等，下面是一个free命令的执行结果：

![](https://upload-images.jianshu.io/upload_images/6549967-5c4bad6a734d5baf.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/599/format/webp)

要了解Linux的内存管理，首先要明白上例中各个名词的意义：

- total：物理内存的总大小。
- used：已经使用的物理内存多小。
- free：空闲的物理内存值。
- shared：多个进程共享的内存值。
- buffers / cached：用于磁盘缓存的大小（这部分是从物理内存中划出来的）。
- 第二行Mem：代表物理内存使用情况。
- 第三行(-/+ buffers/cached)：代表磁盘缓存使用状态。
- 第四行:Swap表示交换空间内存使用状态（这部分实际上是从磁盘上虚拟出来的逻辑内存）。

 free命令输出的内存状态，可以从两个角度来看：内核角度、应用层角度。

 ##1. 从内核角度来查看内存的状态：

 就是内核目前可以直接分配到，不需要额外的操作，即free命令第二行 Mem 的输出。从上例中可见，<font color=red>41940 + 16360492 = 16402432</font>，也就是说Mem行的<font color=red> free + used = total</font>，注意，这里的free并不包括buffers和cached。

 ##2. 从应用层角度来查看内存的状态：

 也就是Linux上运行的程序可以使用的内存大小，即free命令第三行 -/+ buffers/cache 的输出。再来做一个计算<font color=red>41940＋（465404＋12714880）＝13222224</font>，即Mem行的<font color=red>free + buffers + cached = -/+ buffers/cache行的free</font>，也就是说应用可用的物理内存值是Mem行的free、buffers和cached三者之和，可见-/+ buffers/cache行的free是包括buffers和cached的。

 对于应用程序来说，buffers/cached占有的内存是可用的，因为buffers/cached是为了提高文件读取的性能，当应用程序需要用到内存的时候，buffers/cached会很快地被回收，以供应用程序使用。

 ###物理内存和虚拟内存
 物理内存就是系统硬件提供的内存大小，是真正的内存。在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为 交换空间（Swap Space） 。

 linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。而进行这种交换所遵循的依据是“LRU”算法（Least Recently Used，最近最少使用算法）。

 ###Buffers和Cached有什么用
 在任何系统中，文件的读写都是一个耗时的操作，当应用程序需要读写文件中的数据时，操作系统先分配一些内存，将数据从磁盘读入到这些内存中，然后应用程序读写这部分内存数据，之后系统再将数据从内存写到磁盘上。如果是大量文件读写甚至重复读写，系统读写性能就变得非常低下，在这种情况下，Linux引入了缓存机制。

 buffers与cached都是从物理内存中分离出来的，主要用于实现磁盘缓存，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在buffers与cached内存区查找，如果找到，直接读出传送给应用程序，否则，才从磁盘读取，通过这种缓存机制，大大降低了对磁盘的IO操作，提高了操作系统的数据访问性能。而这种磁盘高速缓存则是基于两个事实：第一，内存访问速度远远高于磁盘访问速度；第二，数据一旦被访问，就很有可能短期内再次被访问。

 另外，buffers与cached缓存的内容也是不同的。buffers是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而cached是用来给文件做缓冲。更通俗一点说：buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。

 为了验证我们的结论是否正确，可以通过vi打开一个非常大的文件，看看cached的变化，然后再次vi这个文件，感觉一下是不是第二次打开的速度明显快于第一次？

 接着执行下面的命令：

```shell
 find /* -name  *.conf
```

 看看buffers的值是否变化，然后重复执行find命令，看看两次显示速度有何不同。

 Linux内存管理的哲学

 Free memory is wasted memory.

 **Linux的哲学是尽可能多的使用内存，减少磁盘IO，因为内存的速度比磁盘快得多。** Linux总是在力求缓存更多的数据和信息，内存不够时，将一些不经常使用的数据转移到交换分区（Swap Space）中以释放更多可用物理内存，当然，如果交换分区的数据再次被读写时，又会被转移到物理内存中，这种设计思路提高了系统的整体性能。而Windows的处理方式是，内存和虚拟内存一起使用，不是以内存操作为主，结果就是IO的负担比较大，可能拖慢处理速度。

 ##Linux和Windows在内存管理机制上的区别

 在Linux系统使用过程中，你会发现，无论你的电脑内存配置多么优越，仍然不时的发生可用内存吃紧的现象，感觉内存不够用了，其实不然。这是Linux内存管理的优秀特性，**无论物理内存有多大，Linux都将其充分利用，将一些程序调用过的硬盘数据缓存到内存，利用内存读写的高速性提高系统的数据访问性能。而Window只在需要内存时，才为应用分配内存，不能充分利用大容量的内存空间。** 换句话说，每增加一些内存，Linux都能将其利用起来，充分发挥硬件投资带来的好处，而Windows只将其作为摆设。

 所以说，**一般我们不需要太关注Linux的内存占用情况，而如果Swap占用率一直居高不下的话，就很有可能真的是需要扩展内存了。**
